
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Nemesis</title>
    <style>
        body {
            font-family: 'Arial Black', sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a1a url('https://i.imgur.com/KzcmBtg.png') no-repeat center center fixed;
            background-size: cover;
            color: #fff;
            overflow: hidden;
        }
        #game {
            max-width: 1280px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .game-boards {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            gap: 10px;
        }
        .hero-area {
            width: 300px;
            height: 120px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #ffd700;
            border-radius: 12px;
            box-shadow: 0 0 15px #ffd700;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .hero-area:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px #ffd700;
        }
        .character {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #player-avatar, #ai-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid #ffd700;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        #ai-avatar {
            background: url('https://i.imgur.com/o7ZWJcL.png') no-repeat center;
            background-size: cover;
        }
        .stats-box {
            position: absolute;
            right: -140px;
            top: 50%;
            transform: translateY(-50%);
            width: 120px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .health-display {
            display: inline-block;
            width: 50px;
            height: 30px;
            background: #ff0000;
            color: #fff;
            text-align: center;
            line-height: 30px;
            border-radius: 4px;
            transition: background 0.3s ease;
        }
        .mana-display {
            display: inline-block;
            width: 50px;
            height: 30px;
            background: #00b7eb;
            color: #fff;
            text-align: center;
            line-height: 30px;
            border-radius: 4px;
        }
        .minion-board {
            width: 900px;
            height: 140px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: url('https://i.imgur.com/pogh99r.png') no-repeat center;
            background-size: cover;
            border: 3px solid #666;
            border-radius: 10px;
            margin: 0 auto;
            transition: border 0.2s ease, transform 0.2s ease;
        }
        .minion-board:hover {
            border: 3px solid #ffd700;
            transform: scale(1.01);
        }
        #player-hand {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            height: 160px;
            display: flex;
            justify-content: right;
            align-items: flex-end;
            padding: 10px;
            overflow: visible;
        }
        #player-hand .card {
            position: relative;
            width: 100px;
            height: 150px;
            padding: 10px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border: 3px solid #ffd700;
            background-color: rgba(68, 68, 68, 0.8);
            background-blend-mode: overlay;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            transform-origin: bottom center;
            margin: 0 -30px;
        }
        #player-hand .card:hover {
            transform: translateY(-20px) scale(1.2);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.8);
            z-index: 10;
        }
        #ai-hand {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        #ai-hand .ai-card-back {
            width: 60px;
            height: 90px;
            background: url('https://i.imgur.com/LVCaPdg.png') no-repeat center;
            background-size: cover;
            border: 2px solid #ffd700;
            border-radius: 6px;
            box-shadow: 0 0 5px #ffd700;
        }
        #deck {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            width: 80px;
            height: 120px;
            background: url('https://i.imgur.com/LVCaPdg.png') no-repeat center;
            background-size: cover;
            border: 3px solid #ffd700;
            border-radius: 8px;
            box-shadow: 0 0 10px #ffd700;
            transition: transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        #deck:hover {
            transform: translateY(-50%) scale(1.05);
        }
        #graveyard, #ai-graveyard {
            position: absolute;
            width: 100px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 8px;
            overflow-y: auto;
            padding: 5px;
        }
        #graveyard {
            bottom: 10px;
            left: 20px;
        }
        #ai-graveyard {
            top: 100px;
            right: 20px;
        }
        .graveyard-card {
            width: 80px;
            height: 120px;
            margin: 5px auto;
            background: #333;
            border: 2px solid #ffd700;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        #starting-deck {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffd700;
            border-radius: 12px;
            box-shadow: 0 0 20px #ffd700;
            z-index: 100;
        }
        #selection-text {
            font-size: 20px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 8px #ffd700;
        }
        #starting-deck-cards {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        #starting-deck .card:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px #00ff00;
        }
        #confirm-selection {
            padding: 12px 24px;
            background: #ffd700;
            color: #000;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
        #confirm-selection:hover {
            background: #ffeb3b;
            transform: scale(1.05);
        }
        .card {
            position: relative;
            width: 80px;
            height: 120px;
            padding: 8px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border: 3px solid #ffd700;
            background-color: rgba(68, 68, 68, 0.8);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #ffd700;
        }
        .card.selected {
            border: 3px solid #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }
        .card.exhausted {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .card.can-attack:hover {
            border: 3px solid #ff4500;
            box-shadow: 0 0 15px #ff4500;
        }
        .card.taunt {
            border: 4px solid #00b7eb;
            box-shadow: 0 0 12px #00b7eb;
        }
        .card-name {
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: bold;
            color: #ffd700;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            width: 90%;
            text-align: center;
        }
        .card-description {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            width: 90%;
            text-align: center;
        }
        .card-cost, .card-attack, .card-health {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .card-cost {
            top: 20px;
            right: 5px;
            color: #00b7eb;
            background: rgba(0, 0, 0, 0.7);
        }
        .card-attack {
            bottom: 5px;
            left: 5px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.7);
        }
        .card-health {
            bottom: 5px;
            right: 5px;
            color: #fff;
            background: #ff0000;
        }
        .drop-target.drag-over {
            border: 3px dashed #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        .end-turn-btn {
            position: absolute;
            bottom: 180px;
            right: 20px;
            width: 120px;
            height: 50px;
            background: url('https://i.imgur.com/uCUHUNs.jpeg') no-repeat center;
            background-size: cover;
            border: 3px solid #ffd700;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
            box-shadow: 0 0 15px #ff4500;
        }
        .end-turn-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 0 20px #ff4500;
        }
        .end-turn-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: 0 0 5px #ff4500;
        }
        #restart-btn {
            position: absolute;
            top: 20px;
            right: 160px;
            padding: 10px 20px;
            background: #ff4500;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
        #restart-btn:hover {
            background: #ff6347;
            transform: scale(1.05);
        }
        #back-to-codex-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #00b7eb;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: none;
        }
        #back-to-codex-btn:hover {
            background: #00d4ff;
            transform: scale(1.05);
        }
        .log-box {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 200px;
            height: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            padding: 10px;
            overflow-y: auto;
            font-size: 14px;
            border-radius: 8px;
            box-shadow: 0 0 10px #ffd700;
        }
        .log-box p {
            margin: 5px 0;
        }
        .mana-bar {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 5px;
            overflow: hidden;
        }
        .mana-fill {
            height: 100%;
            background: #00b7eb;
            transition: width 0.3s ease;
        }
        #turn-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
        }
        .heal-animation {
            animation: healSparkle 1s ease-in-out;
        }
        @keyframes healSparkle {
            0% { box-shadow: 0 0 10px #00ff00; }
            50% { box-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00; }
            100% { box-shadow: 0 0 10px #00ff00; }
        }
        .attack-animation {
            animation: attackPulse 0.5s ease-in-out;
        }
        @keyframes attackPulse {
            0% { transform: scale(1); box-shadow: 0 0 0 #ff4500; }
            50% { transform: scale(1.1); box-shadow: 0 0 15px #ff4500; }
            100% { transform: scale(1); box-shadow: 0 0 0 #ff4500; }
        }
        .spell-projectile {
            position: absolute;
            width: 60px;
            height: 60px;
            background: url('https://i.imgur.com/KfE0K3N.png') no-repeat center;
            background-size: contain;
            z-index: 20;
            animation: flyToTarget 0.8s ease-out forwards;
        }
        @keyframes flyToTarget {
            0% { opacity: 1; transform: scale(0.5); }
            80% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1); }
        }
        .spell-impact {
            position: absolute;
            width: 100px;
            height: 100px;
            background: url('https://i.imgur.com/vUfG5PJ.png') no-repeat center;
            background-size: contain;
            z-index: 21;
            animation: impactBurst 0.6s ease-out forwards;
        }
        @keyframes impactBurst {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .damage-circles {
            position: absolute;
            width: 80px;
            height: 80px;
            z-index: 22;
        }
        .damage-circle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff4500 30%, transparent 70%);
            border-radius: 50%;
            animation: damageRipple 0.5s ease-out forwards;
        }
        @keyframes damageRipple {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        .mana-gain {
            animation: manaGlow 0.7s ease-in-out;
        }
        @keyframes manaGlow {
            0% { box-shadow: 0 0 10px #00b7eb; }
            50% { box-shadow: 0 0 20px #00b7eb, 0 0 30px #00b7eb; }
            100% { box-shadow: 0 0 10px #00b7eb; }
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            color: #fff;
            max-width: 200px;
            z-index: 100;
            display: none;
        }
        #tooltip.show {
            display: block;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffd700;
            border-radius: 12px;
            text-align: center;
            z-index: 100;
        }
        #game-over h2 {
            color: #ffd700;
            font-size: 24px;
        }
        #game-over p {
            font-size: 18px;
        }
        #game-over button {
            padding: 10px 20px;
            background: #ffd700;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        #game-over button:hover {
            background: #ffeb3b;
            transform: scale(1.05);
        }
        .discord-button-container {
            position: fixed;
            top: 0;
            left: 65%;
            transform: translateX(-50%);
            z-index: 9999;
            padding: 20px;
        }
        .discord-button {
            display: block;
            position: relative;
            transition: all 0.3s ease;
            border-radius: 15px;
            padding: 3px;
            background: transparent;
            border: 3px solid #000;
            box-shadow: 0 0 0 2px #000;
        }
        .discord-button::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 15px;
            background: linear-gradient(45deg, #ff8a00, #ffd700, #ff8a00, #ffd700);
            z-index: -1;
            background-size: 400% 400%;
            filter: blur(5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .discord-button:hover {
            transform: scale(1.1) rotate(2deg);
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 138, 0, 0.5);
        }
        .discord-button:hover::before {
            opacity: 1;
            animation: borderRotate 1s linear infinite;
        }
        .discord-button:hover::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 15px;
            background: radial-gradient(circle at center, rgba(255, 138, 0, 0.2), rgba(255, 215, 0, 0.2), transparent 70%);
            z-index: -1;
            animation: swirl 2s linear infinite;
        }
        .discord-button img {
            width: 200px;
            height: auto;
            border-radius: 10px;
            display: block;
            position: relative;
            z-index: 1;
            transition: all 0.3s ease;
        }
        .discord-button:hover img {
            transform: scale(1.05) rotate(-2deg);
            filter: brightness(1.1);
        }
        @keyframes borderRotate {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes swirl {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .button-background {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 250px;
            height: 250px;
            background: radial-gradient(circle at center, rgba(255, 138, 0, 0.3), rgba(255, 215, 0, 0.2), transparent 70%);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: -2;
        }
        .discord-button:hover .button-background {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
        }
        @media (max-width: 768px) {
            .discord-button-container { left: 50%; }
            .discord-button img { width: 150px; }
            .button-background { width: 200px; height: 200px; }
        }
    </style>
</head>
<body>
    <div class="discord-button-container">
        <a href="https://discord.com/oauth2/authorize?client_id=1342593452793270302&response_type=code&redirect_uri=https%3A%2F%2Fwww.grudgeplatform.com%2FSeason0&scope=identify" 
            class="discord-button"
            target="_blank"
            rel="noopener noreferrer">
            <div class="button-background"></div>
            <img src="https://i.imgur.com/SRoq392.png"
                alt="Connect with Discord"
                title="Connect with Discord">
        </a>
    </div>
    <div id="game">
        <div id="ai-hand"></div>
        <div class="game-boards">
            <div class="hero-area drop-target" id="ai-health-board">
                <div class="character drop-target" id="ai-hero-image">
                    <div id="ai-avatar"></div>
                    <div class="stats-box drop-target" id="ai-stats-box">
                        Health: <span id="ai-health" class="health-display">30</span><br>
                        Mana: <span id="ai-mana" class="mana-display">0</span>/<span id="ai-max-mana">0</span>
                    </div>
                </div>
            </div>
            <div id="ai-minion-board" class="minion-board drop-target"></div>
            <div id="player-minion-board" class="minion-board drop-target"></div>
            <div class="hero-area drop-target" id="hero-health-board">
                <div class="character drop-target" id="player-hero-image">
                    <img id="player-avatar" src="https://i.imgur.com/sample-avatar.png" alt="Player Avatar">
                    <div class="stats-box drop-target" id="player-stats-box">
                        Health: <span id="player-health" class="health-display">30</span><br>
                        Mana: <span id="player-mana" class="mana-display">0</span>/<span id="player-max-mana">0</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="player-hand"></div>
        <div id="deck"></div>
        <div id="graveyard"></div>
        <div id="ai-graveyard"></div>
        <div class="log-box" id="log">Battle Log</div>
        <div class="mana-bar"><div class="mana-fill" id="mana-fill"></div></div>
        <div id="turn-indicator">Player's Turn</div>
        <button id="end-turn" class="end-turn-btn" type="button" disabled>End Turn</button>
        <button id="restart-btn" type="button">Restart Game</button>
        <button id="back-to-codex-btn" type="button">Back to Codex</button>
        <div id="tooltip"></div>
        <div id="game-over" style="display: none;"></div>
    </div>
    <script>
        // Card data for Season 0
    const season0 = [
    { id: 1, name: "Night Wraith", cost: 4, attack: 4, health: 3, type: "minion", description: "Stealth: Ignores Taunt on first attack.", backgroundImage: "https://i.imgur.com/PSpj7sO.png", uid: "season0_1", ability: "stealth" },
    { id: 2, name: "Mana Surge", cost: 0, type: "spell", description: "Gain 2 mana this turn only.", backgroundImage: "https://i.imgur.com/dU3QrVi.png", uid: "season0_2" },
    { id: 3, name: "Stoned Ape", cost: 8, attack: 8, health: 8, taunt: true, type: "minion", description: "Taunt: Must be attacked first.", backgroundImage: "https://i.imgur.com/iWv48Xl.png", uid: "season0_3" },
    { id: 4, name: "Stealth Drone", cost: 1, attack: 1, health: 1, type: "minion", description: "Quick scouting unit.", backgroundImage: "https://i.imgur.com/zMFckYB.png", uid: "season0_4" },
    { id: 5, name: "Mace Assassin", cost: 3, attack: 4, health: 2, type: "minion", description: "Deals double damage to heroes.", backgroundImage: "https://i.imgur.com/3SkE6VG.png", uid: "season0_5", ability: "heroDoubleDamage" },
    { id: 6, name: "Barrier Sentinel", cost: 5, attack: 0, health: 7, taunt: true, type: "minion", description: "Taunt: Blocks all attacks.", backgroundImage: "https://i.imgur.com/klAa6aX.png", uid: "season0_6" },
    { id: 7, name: "Swarm Legion", cost: 3, attack: 3, health: 3, type: "minion", description: "Summons two 1/1 Drones on play.", backgroundImage: "https://i.imgur.com/Wn84v6I.png", uid: "season0_7", ability: "summon", summonCount: 2 },
    { id: 8, name: "Quantum Behemoth", cost: 7, attack: 6, health: 6, type: "minion", description: "Deals 2 damage to all enemies on play.", backgroundImage: "https://i.imgur.com/Y67jKrU.png", uid: "season0_8", ability: "dealDamage", damage: 2 },
    { id: 9, name: "Arcane Mystic", cost: 2, attack: 2, health: 3, type: "minion", description: "Restores 2 mana on attack.", backgroundImage: "https://i.imgur.com/Enu1T7Y.png", uid: "season0_9", ability: "manaRestore", manaRestore: 2 },
    { id: 10, name: "Overcharged Titan", cost: 8, attack: 7, health: 6, type: "minion", description: "Gives +2 attack to all allies.", backgroundImage: "https://i.imgur.com/s0cMpSi.png", uid: "season0_10", ability: "boostAllies", boostAttack: 2 },
    { id: 13, name: "Night Lord", cost: 4, attack: 4, health: 3, type: "minion", description: "Stealth: Ignores Taunt on first attack.", backgroundImage: "https://i.imgur.com/qpsLIcS.png", uid: "season0_13", ability: "stealth" },
    { id: 14, name: "Crimson Revenant", cost: 4, attack: 4, health: 3, type: "minion", description: "Heals hero for 2 on attack.", backgroundImage: "https://i.imgur.com/8YIqCl5.png", uid: "season0_14", ability: "heroHeal", heal: 2 },
    { id: 15, name: "Emerald Stalker", cost: 4, attack: 4, health: 3, type: "minion", description: "Gains +1 attack after attacking.", backgroundImage: "https://i.imgur.com/5t6kGOi.jpeg", uid: "season0_15", ability: "attackBoost", attackBoost: 1 },
    { id: 19, name: "Arcane Burst", cost: 3, damage: 4, type: "directDamage", description: "Deals 4 damage to a target.", backgroundImage: "https://i.imgur.com/sZEdhnc.png", uid: "season0_19" },
    { id: 20, name: "Void Rift", cost: 3, damage: 4, type: "directDamage", description: "Deals 4 damage to a target.", backgroundImage: "https://i.imgur.com/KjBYZ7L.png", uid: "season0_20" },
    { id: 21, name: "Celestial Warden", cost: 6, attack: 5, health: 5, type: "minion", description: "Heals all allies for 2 each turn.", backgroundImage: "https://i.imgur.com/6CXJn5s.png", uid: "season0_21", healAll: 2 },
    { id: 22, name: "Abyssal Keeper", cost: 6, attack: 5, health: 5, type: "minion", description: "Heals all allies for 2 each turn.", backgroundImage: "https://i.imgur.com/3b2RmGQ.png", uid: "season0_22", healAll: 2 },
    { id: 23, name: "Storm Cavalier", cost: 4, attack: 4, health: 4, type: "minion", description: "Deals 1 damage to random enemy on attack.", backgroundImage: "https://i.imgur.com/nBUKWdy.png", uid: "season0_23", ability: "randomDamage", damage: 1 },
    { id: 24, name: "Flame Charger", cost: 4, attack: 4, health: 4, type: "minion", description: "Deals 1 damage to all enemies on play.", backgroundImage: "https://i.imgur.com/cep6ytB.png", uid: "season0_24", ability: "dealDamage", damage: 1 },
    { id: 25, name: "Ra Cal Vin", cost: 4, attack: 4, health: 4, type: "minion", description: "Draw a card on play.", backgroundImage: "https://i.imgur.com/XbSuPyC.png", uid: "season0_25", ability: "drawCard", drawCount: 1 },
    { id: 26, name: "Void Sorcerer", cost: 5, attack: 3, health: 4, taunt: true, type: "minion", description: "Taunt: Blocks attacks.", backgroundImage: "https://i.imgur.com/2XhqS6d.png", uid: "season0_26" },
    { id: 27, name: "Light Mage", cost: 5, attack: 3, health: 4, taunt: true, type: "minion", description: "Taunt: Blocks attacks.", backgroundImage: "https://i.imgur.com/cMLK4Oq.png", uid: "season0_27" },
    { id: 28, name: "Epic Strike", cost: 4, damage: 6, type: "directDamage", description: "Deals 6 damage to a target.", backgroundImage: "https://i.imgur.com/YxGHZ7l.png", uid: "season0_28" },
    { id: 29, name: "Chaos Vortrx", cost: 4, damage: 6, type: "directDamage", description: "Deals 6 damage to a target.", backgroundImage: "https://i.imgur.com/dramBbf.png", uid: "season0_29" },
    { id: 30, name: "Spectral Warrior", cost: 5, attack: 5, health: 4, type: "minion", description: "Restores 2 health to hero on play.", backgroundImage: "https://i.imgur.com/n2b1ugT.png", uid: "season0_30", ability: "heroHeal", heal: 2 },
    { id: 31, name: "Radiant Paladin", cost: 5, attack: 5, health: 4, type: "minion", description: "Gives +1 health to all allies on play.", backgroundImage: "https://i.imgur.com/TalRqz3.png", uid: "season0_31", ability: "boostAllies", boostHealth: 1 },
    { id: 32, name: "Ethereal Phantom", cost: 3, attack: 2, health: 3, type: "minion", description: "Stealth: Ignores Taunt on first attack.", backgroundImage: "https://i.imgur.com/v0RBTiV.png", uid: "season0_32", ability: "stealth" },
    { id: 33, name: "Crimson Shade", cost: 3, attack: 2, health: 3, type: "minion", description: "Deals 1 damage to hero on attack.", backgroundImage: "https://i.imgur.com/36iR3J8.png", uid: "season0_33", ability: "heroDamage", damage: 1 },
    { id: 34, name: "Logs Much", cost: 3, attack: 2, health: 3, type: "minion", description: "Gains +1 health on attack.", backgroundImage: "https://i.imgur.com/PFbnxct.png", uid: "season0_34", ability: "healthBoost", healthBoost: 1 },
    { id: 35, name: "Abyssal Monolith", cost: 7, attack: 6, health: 6, taunt: true, type: "minion", description: "Taunt: Blocks attacks.", backgroundImage: "https://i.imgur.com/1VehWYG.png", uid: "season0_35" },
    { id: 36, name: "Celestial Serph", cost: 7, attack: 6, health: 6, taunt: true, type: "minion", description: "Taunt: Blocks attacks.", backgroundImage: "https://i.imgur.com/GvWB71v.png", uid: "season0_36" },
    { id: 37, name: "Thundering Yordy", cost: 6, attack: 5, health: 5, type: "minion", description: "Deals 2 damage to random enemy on play.", backgroundImage: "https://i.imgur.com/UvZsOLQ.png", uid: "season0_37", ability: "dealDamage", damage: 2 },
    { id: 38, name: "Flame Dragon", cost: 6, attack: 5, health: 5, type: "minion", description: "Deals 3 damage to all enemies on play.", backgroundImage: "https://i.imgur.com/BocWQdv.png", uid: "season0_38", ability: "dealDamage", damage: 3 },
    { id: 39, name: "Star Traveler", cost: 6, attack: 5, health: 5, type: "minion", description: "Draw 2 cards on play.", backgroundImage: "https://i.imgur.com/I3o9UZS.png", uid: "season0_39", ability: "drawCard", drawCount: 2 },
    { id: 40, name: "Starfire Nova", cost: 5, damage: 8, type: "directDamage", description: "Deals 8 damage to a target.", backgroundImage: "https://i.imgur.com/Et512Ly.png", uid: "season0_40" },
    { id: 41, name: "Moonfire Wave", cost: 5, damage: 8, type: "directDamage", description: "Deals 8 damage to a target.", backgroundImage: "https://i.imgur.com/1iicyne.png", uid: "season0_41" },
    { id: 42, name: "Flame Pulse", cost: 4, damage: 6, type: "directDamage", description: "Deals 6 damage to a target.", backgroundImage: "https://i.imgur.com/5PSOVVc.png", uid: "season0_42" },
    { id: 43, name: "Thunder Strike", cost: 6, damage: 7, type: "directDamage", description: "Deals 7 damage to a target.", backgroundImage: "https://i.imgur.com/8DLbQp4.png", uid: "season0_43" },
    { id: 44, name: "Void Eruption", cost: 8, damage: 10, type: "directDamage", description: "Deals 10 damage to a target.", backgroundImage: "https://i.imgur.com/KEPxMIp.png", uid: "season0_44" },
    { id: 45, name: "Desperate Repair", cost: 2, healing: 5, type: "healing", description: "Restores 5 health to a target.", backgroundImage: "https://i.imgur.com/dyC5M5D.png", uid: "season0_45" },
    { id: 46, name: "Core Renewal", cost: 4, healing: 8, type: "healing", description: "Restores 8 health to a target.", backgroundImage: "https://i.imgur.com/3cpJ2XF.png", uid: "season0_46" },
    { id: 47, name: "Vital Infusion", cost: 6, healing: 10, type: "healing", description: "Restores 10 health to a target.", backgroundImage: "https://i.imgur.com/BmCZ9hn.png", uid: "season0_47" },
    { id: 48, name: "Life Cascade", cost: 8, healing: 12, type: "healing", description: "Restores 12 health to a target.", backgroundImage: "https://i.imgur.com/C75RopO.png", uid: "season0_48" },
    { id: 49, name: "Fire Surge", cost: 0, type: "spell", description: "Gain 2 mana this turn only.", backgroundImage: "https://i.imgur.com/vUfG5PJ.png", uid: "season0_49" },
    { id: 50, name: "Tactical Insight", cost: 3, type: "spellDraw", description: "Draw 2 cards.", backgroundImage: "https://i.imgur.com/LhKeIUk.png", uid: "season0_50", drawCount: 2 },
    { id: 51, name: "Luminous Watcher", cost: 3, attack: 2, health: 3, type: "minion", description: "Heals all allies for 1 each turn.", backgroundImage: "https://i.imgur.com/eg8FESL.png", uid: "season0_51", healAll: 1 },
    { id: 52, name: "Vitality Totem", cost: 5, attack: 3, health: 5, type: "minion", description: "Heals all allies for 2 each turn.", backgroundImage: "https://i.imgur.com/SAL2oQY.png", uid: "season0_52", healAll: 2 },
    { id: 53, name: "Alpha Skiff", cost: 2, attack: 1, health: 2, type: "minion", description: "Deals 2 damage to a target on play.", backgroundImage: "https://i.imgur.com/z1fbkXx.png", uid: "season0_53", ability: "dealDamage", damage: 2 },
    { id: 54, name: "Beta Cruiser", cost: 4, attack: 3, health: 3, type: "minion", description: "Deals 5 damage to a target on play.", backgroundImage: "https://i.imgur.com/JuxTEX9.png", uid: "season0_54", ability: "dealDamage", damage: 5 },
    { id: 55, name: "Omega Dreadnought", cost: 6, attack: 4, health: 5, type: "minion", description: "Gives +1 attack to all allies on play.", backgroundImage: "https://i.imgur.com/Phx6yjU.png", uid: "season0_55", ability: "boostAllies", boostAttack: 1 },
    { id: 56, name: "A Coward Priest", cost: 1, attack: 1, health: 1, type: "minion", description: "Restores 2 health to hero on play.", backgroundImage: "https://i.imgur.com/DHS25YU.jpeg", uid: "season0_56", ability: "heroHeal", heal: 2 },
    { id: 57, name: "Patrol Frigate", cost: 3, attack: 2, health: 3, type: "minion", description: "Draw a card on attack.", backgroundImage: "https://i.imgur.com/nJMY8NA.png", uid: "season0_57", ability: "drawCard", drawCount: 1 },
    { id: 58, name: "Ironclad Titan", cost: 5, attack: 4, health: 4, type: "minion", description: "Gains +2 armor on play.", backgroundImage: "https://i.imgur.com/yUzjTDm.png", uid: "season0_58", ability: "gainArmor", armor: 2 },
    { id: 59, name: "Skull Hex", cost: 3, damage: 3, type: "directDamage", description: "Deals 3 damage to a target.", backgroundImage: "https://i.imgur.com/XOkb25e.jpg", uid: "season0_59" },
    { id: 60, name: "Overlord Mind", cost: 5, attack: 4, health: 4, taunt: true, type: "minion", description: "Taunt: Blocks attacks.", backgroundImage: "https://i.imgur.com/LspYMpz.png", uid: "season0_60" },
    { id: 61, name: "Dragon King", cost: 7, attack: 5, health: 5, type: "minion", description: "Deals 3 damage to all enemies on play.", backgroundImage: "https://i.imgur.com/uaeSik8.png", uid: "season0_61", ability: "dealDamage", damage: 3 },
    { id: 62, name: "Enigmatic Warrior", cost: 4, attack: 3, health: 3, type: "minion", description: "Gains +1 attack on attack.", backgroundImage: "https://i.imgur.com/JwcxWth.png", uid: "season0_62", ability: "attackBoost", attackBoost: 1 },
    { id: 63, name: "Battle Commander", cost: 3, attack: 2, health: 4, type: "minion", description: "Gives +1 attack to adjacent minions.", backgroundImage: "https://i.imgur.com/ABsno64.png", uid: "season0_63", ability: "boostAdjacent", boostAttack: 1 },
    { id: 64, name: "Orcish Sniper", cost: 2, attack: 2, health: 1, type: "minion", description: "Deals 1 damage to a random enemy on play.", backgroundImage: "https://i.imgur.com/nlkfMpI.png", uid: "season0_64", ability: "dealDamage", damage: 1 },
    { id: 65, name: "Valor Knight", cost: 6, attack: 5, health: 4, type: "minion", description: "Restores 4 health to hero on play.", backgroundImage: "https://i.imgur.com/LjBBzdn.png", uid: "season0_65", ability: "heroHeal", heal: 4 },
    { id: 66, name: "Starborn Light", cost: 1, attack: 1, health: 1, type: "minion", description: "Summons a 1/1 Drone on play.", backgroundImage: "https://i.imgur.com/AvsiFog.png", uid: "season0_66", ability: "summon", summonCount: 1 },
    { id: 67, name: "GwA Hero", cost: 8, attack: 8, health: 8, taunt: true, type: "minion", description: "Taunt: Blocks attacks.", backgroundImage: "https://i.imgur.com/wFYPeDJ.png", uid: "season0_67" },
    { id: 68, name: "Abyssal Leviathan", cost: 8, attack: 7, health: 9, type: "minion", description: "Deals 3 damage to a target on play.", backgroundImage: "https://i.imgur.com/SbU1dfG.png", uid: "season0_68", ability: "dealDamage", damage: 3 }
];
    

    class Game {
            constructor() {
                this.state = {
                    player: { health: 30, mana: 0, maxMana: 0, hand: [], board: [], deck: [], graveyard: [], armor: 0 },
                    ai: { health: 30, mana: 0, maxMana: 0, hand: [], board: [], deck: [], graveyard: [], armor: 0 },
                    turn: 'player',
                    turnNumber: 1,
                    selectedCard: null,
                    attackingMinion: null,
                    gameOver: false,
                    startingDeck: [],
                    swapsLeft: 3,
                    playerWins: 0,
                    aiWins: 0
                };
                this.elements = {
                    playerHand: document.getElementById('player-hand'),
                    playerBoard: document.getElementById('player-minion-board'),
                    aiBoard: document.getElementById('ai-minion-board'),
                    aiHand: document.getElementById('ai-hand'),
                    deck: document.getElementById('deck'),
                    graveyard: document.getElementById('graveyard'),
                    aiGraveyard: document.getElementById('ai-graveyard'),
                    log: document.getElementById('log'),
                    manaFill: document.getElementById('mana-fill'),
                    turnIndicator: document.getElementById('turn-indicator'),
                    endTurnBtn: document.getElementById('end-turn'),
                    restartBtn: document.getElementById('restart-btn'),
                    backToCodexBtn: document.getElementById('back-to-codex-btn'),
                    playerAvatar: document.getElementById('player-avatar'),
                    tooltip: document.getElementById('tooltip'),
                    gameOver: document.getElementById('game-over')
                };
                this.maxHealth = 100;
                this.maxArmor = 50;
                this.maxHandSize = 10;
                this.maxBoardSize = 7;
            }

            async init() {
                const discordUser = JSON.parse(sessionStorage.getItem('discordUser') || '{}');
                if (discordUser.id && discordUser.avatar) {
                    this.elements.playerAvatar.src = `https://cdn.discordapp.com/avatars/${discordUser.id}/${discordUser.avatar}.png`;
                }
                this.state.player.deck = this.shuffle([...season0]);
                this.state.ai.deck = this.generateAIDeck();
                this.addLog("AI deck generated with balanced card distribution.");
                this.state.startingDeck = this.state.player.deck.splice(0, 5);
                this.setupUI();
                this.showStartingDeck();
                this.addLog("Game started! Select up to 3 cards to swap.");
            }

            shuffle(deck) {
                return deck.map(card => ({ ...card, uid: Math.random().toString(36).substr(2, 9) }))
                    .sort(() => Math.random() - 0.5);
            }

            generateAIDeck() {
                const lowCost = season0.filter(c => c.cost <= 3);
                const midCost = season0.filter(c => c.cost === 4 || c.cost === 5);
                const highCost = season0.filter(c => c.cost >= 6);
                const deck = [
                    ...this.shuffle(lowCost).slice(0, 10),
                    ...this.shuffle(midCost).slice(0, 6),
                    ...this.shuffle(highCost).slice(0, 4)
                ];
                return this.shuffle(deck);
            }

            setupUI() {
                this.elements.endTurnBtn.addEventListener('click', () => this.endTurn());
                this.elements.restartBtn.addEventListener('click', () => this.restart());
                this.elements.backToCodexBtn.addEventListener('click', () => this.backToCodex());
                document.querySelectorAll('.drop-target').forEach(target => {
                    target.addEventListener('dragover', e => {
                        e.preventDefault();
                        if (this.state.turn === 'player' && !this.state.gameOver) {
                            target.classList.add('drag-over');
                        }
                    });
                    target.addEventListener('dragleave', () => target.classList.remove('drag-over'));
                    target.addEventListener('drop', e => {
                        target.classList.remove('drag-over');
                        this.handleDrop(e);
                    });
                });
                this.elements.aiBoard.addEventListener('click', e => this.handleBoardClick(e));
                document.addEventListener('mousemove', e => this.updateTooltipPosition(e));
            }

            showStartingDeck() {
                const container = document.createElement('div');
                container.id = 'starting-deck';
                container.innerHTML = `
                    <div id="selection-text">SELECT CARDS TO SWAP (${this.state.swapsLeft} LEFT)</div>
                    <div id="starting-deck-cards"></div>
                    <button id="confirm-selection" type="button">Confirm</button>
                `;
                document.getElementById('game').appendChild(container);

                const cardContainer = document.getElementById('starting-deck-cards');
                this.state.startingDeck.forEach(card => {
                    const cardEl = this.createCard(card);
                    cardEl.addEventListener('click', () => this.swapCard(card));
                    cardContainer.appendChild(cardEl);
                });
                document.getElementById('confirm-selection').addEventListener('click', () => this.confirmDeck());
            }

            swapCard(card) {
                if (this.state.swapsLeft <= 0) return this.addLog("No swaps left!");
                const index = this.state.startingDeck.findIndex(c => c.uid === card.uid);
                if (index !== -1 && this.state.player.deck.length > 0) {
                    const newCard = this.state.player.deck.shift();
                    this.state.startingDeck[index] = { ...newCard, uid: Math.random().toString(36).substr(2, 9) };
                    this.state.player.deck.push(card);
                    this.state.swapsLeft--;
                    this.addLog(`Swapped ${card.name} for ${newCard.name}`);
                    this.updateStartingDeckUI();
                }
            }

            updateStartingDeckUI() {
                const container = document.getElementById('starting-deck');
                if (!container) return;
                container.querySelector('#selection-text').textContent = `SELECT CARDS TO SWAP (${this.state.swapsLeft} LEFT)`;
                const cardContainer = container.querySelector('#starting-deck-cards');
                cardContainer.innerHTML = '';
                this.state.startingDeck.forEach(card => {
                    const cardEl = this.createCard(card);
                    cardEl.addEventListener('click', () => this.swapCard(card));
                    cardContainer.appendChild(cardEl);
                });
            }

            confirmDeck() {
                this.state.player.hand = [...this.state.startingDeck];
                this.state.startingDeck = [];
                this.state.swapsLeft = 0;
                document.getElementById('starting-deck')?.remove();
                this.drawCards('ai', 5);
                this.startTurn('player');
                this.update();
                this.addLog("Game begins! Player's turn.");
            }

            createCard(card, isPlayer = true) {
                const minion = this.state[isPlayer ? 'player' : 'ai'].board.find(m => m.card.uid === card.uid);
                const exhausted = minion?.exhausted || false;
                const canAttack = isPlayer && this.canAttack(card);
                const cardEl = document.createElement('div');
                cardEl.className = `card drop-target ${card.type} ${card.taunt ? 'taunt' : ''} ${exhausted ? 'exhausted' : ''} ${canAttack ? 'can-attack' : ''} ${this.state.selectedCard?.uid === card.uid ? 'selected' : ''}`;
                cardEl.style.backgroundImage = `url('${card.backgroundImage}')`;
                cardEl.innerHTML = `
                    <div class="card-cost">${card.cost}</div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-description">${card.description}</div>
                    ${card.attack !== undefined ? `<div class="card-attack">${minion ? minion.card.attack : card.attack}</div>` : ''}
                    ${card.health !== undefined ? `<div class="card-health">${minion ? minion.card.health : card.health}</div>` : ''}
                `;
                cardEl.dataset.card = JSON.stringify(card);

                if (isPlayer && this.state.turn === 'player' && !this.state.gameOver && !this.state.startingDeck.length) {
                    cardEl.draggable = true;
                    cardEl.addEventListener('dragstart', e => this.handleDragStart(card, e));
                    cardEl.addEventListener('click', () => this.selectCard(card));
                    cardEl.addEventListener('mouseenter', () => this.showTooltip(card, cardEl));
                    cardEl.addEventListener('mouseleave', () => this.hideTooltip());
                }
                return cardEl;
            }

            showTooltip(card, cardEl) {
                const rect = cardEl.getBoundingClientRect();
                this.elements.tooltip.innerHTML = `
                    <strong>${card.name}</strong><br>
                    Cost: ${card.cost}<br>
                    ${card.attack !== undefined ? `Attack: ${card.attack}<br>` : ''}
                    ${card.health !== undefined ? `Health: ${card.health}<br>` : ''}
                    ${card.damage ? `Damage: ${card.damage}<br>` : ''}
                    ${card.healing ? `Healing: ${card.healing}<br>` : ''}
                    ${card.ability ? `Ability: ${card.description}<br>` : ''}
                    Type: ${card.type.charAt(0).toUpperCase() + card.type.slice(1)}
                `;
                this.elements.tooltip.style.left = `${rect.right + 10}px`;
                this.elements.tooltip.style.top = `${rect.top}px`;
                this.elements.tooltip.classList.add('show');
            }

            hideTooltip() {
                this.elements.tooltip.classList.remove('show');
            }

            updateTooltipPosition(e) {
                if (this.elements.tooltip.classList.contains('show')) {
                    this.elements.tooltip.style.left = `${e.clientX + 10}px`;
                    this.elements.tooltip.style.top = `${e.clientY + 10}px`;
                }
            }

            drawCards(player, count) {
                const target = this.state[player];
                for (let i = 0; i < count && target.hand.length < this.maxHandSize; i++) {
                    if (!target.deck.length) {
                        target.health = Math.max(0, target.health - Math.ceil(this.state.turnNumber / 2));
                        this.addLog(`${player === 'player' ? 'Player' : 'AI'} takes ${Math.ceil(this.state.turnNumber / 2)} fatigue damage.`);
                        this.animateDamageCircles(document.getElementById(player === 'player' ? 'hero-health-board' : 'ai-health-board'));
                    } else {
                        target.hand.push(target.deck.shift());
                    }
                }
                this.update();
            }

            startTurn(player) {
                const target = this.state[player];
                target.maxMana = Math.min(10, target.maxMana + 1);
                target.mana = target.maxMana;
                this.drawCards(player, 1);
                target.board.forEach(m => {
                    m.exhausted = false;
                    m.turnsOnBoard = (m.turnsOnBoard || 0) + 1;
                    if (m.card.healAll) {
                        target.board.forEach(min => {
                            min.card.health = Math.min(this.maxHealth, min.card.health + m.card.healAll);
                            this.animateHeal(document.getElementById(player === 'player' ? 'player-minion-board' : 'ai-minion-board').querySelector(`[data-card='${JSON.stringify(min.card)}']`));
                        });
                        target.health = Math.min(this.maxHealth, target.health + m.card.healAll);
                        this.addLog(`${player === 'player' ? 'Player' : 'AI'}'s ${m.card.name} heals all for ${m.card.healAll}`);
                        this.animateHeal(document.getElementById(player === 'player' ? 'hero-health-board' : 'ai-health-board'));
                    }
                });
                this.state.turn = player;
                this.state.turnNumber++;
                this.addLog(`${player === 'player' ? 'Player' : 'AI'}'s Turn ${Math.ceil(this.state.turnNumber / 2)}`);
                this.update();
                if (player === 'ai') {
                    setTimeout(() => this.aiTurn(), 1000);
                }
            }

            endTurn() {
                if (this.state.turn !== 'player' || this.state.gameOver || this.state.startingDeck.length) return;
                this.state.turn = 'ai';
                this.addLog("Player's turn ends.");
                this.update();
                this.startTurn('ai');
            }

            async aiTurn() {
                if (this.state.gameOver) return;
                const boardState = this.evaluateBoardState();
                const hand = [...this.state.ai.hand].sort((a, b) => {
                    if (boardState.shouldPlayDefensively) {
                        return (a.type === 'healing' || a.taunt) ? -1 : 1;
                    }
                    return a.cost - b.cost;
                });
                const targetPriority = this.calculateAITargetPriority();

                const playProbability = boardState.healthDiff > 10 ? 0.9 : boardState.shouldPlayDefensively ? 0.6 : 0.8;
                for (let card of hand) {
                    if (this.state.ai.mana >= card.cost && Math.random() < playProbability) {
                        await this.playAICard(card, targetPriority);
                    }
                }

                const attackableMinions = this.state.ai.board.filter(m => !m.exhausted && m.card.health > 0 && m.card.attack > 0);
                for (let minion of attackableMinions) {
                    const priority = this.calculateAITargetPriority();
                    if (boardState.shouldPlayDefensively && priority.type === 'hero' && Math.random() > 0.3) {
                        continue;
                    }
                    await this.aiAttack(minion, priority);
                }

                this.checkGameEnd();
                if (!this.state.gameOver) {
                    this.state.turn = 'player';
                    this.startTurn('player');
                }
                this.update();
            }

            evaluateBoardState() {
                const playerThreat = this.state.player.board.reduce((sum, m) => sum + m.card.attack + m.card.health, 0);
                const aiThreat = this.state.ai.board.reduce((sum, m) => sum + m.card.attack + m.card.health, 0);
                const healthDiff = this.state.ai.health - this.state.player.health;
                return {
                    playerThreat,
                    aiThreat,
                    healthDiff,
                    boardControl: aiThreat - playerThreat,
                    shouldPlayDefensively: healthDiff < 0 || playerThreat > aiThreat
                };
            }

            calculateAITargetPriority() {
                const playerMinions = this.state.player.board;
                const hasTaunt = playerMinions.some(m => m.card.taunt);
                let priority = hasTaunt ? playerMinions.filter(m => m.card.taunt) : playerMinions;

                if (priority.length === 0 || this.state.player.health <= 10) {
                    return { type: 'hero', target: null };
                }

                priority.sort((a, b) => (b.card.attack / b.card.health) - (a.card.attack / a.card.health));
                return { type: 'minion', target: priority[0]?.card };
            }

            async playAICard(card, targetPriority) {
                this.state.ai.mana -= card.cost;
                this.state.ai.hand = this.state.ai.hand.filter(c => c.uid !== card.uid);
                const cardEl = this.createCard(card, false);
                this.elements.aiHand.appendChild(cardEl);
                await new Promise(resolve => setTimeout(resolve, 800));
                cardEl.remove();

                if (card.type === 'minion' && this.state.ai.board.length < this.maxBoardSize) {
                    this.state.ai.board.push({ card, exhausted: true, armor: 0 });
                    this.addLog(`AI plays ${card.name}`);
                    if (card.ability === 'dealDamage') {
                        await this.handleDealDamage(card, 'player', this.elements.playerBoard, targetPriority);
                    } else if (card.ability === 'boostAllies') {
                        this.state.ai.board.forEach(m => m.card.attack += card.boostAttack);
                        this.addLog(`AI's ${card.name} gives all allies +${card.boostAttack} attack`);
                        await new Promise(resolve => setTimeout(resolve, 800));
                    } else if (card.ability) {
                        await this.handleSpecialAbility(card, 'ai', 'ai-minion-board', this.elements.aiBoard);
                    }
                } else if (card.type === 'directDamage') {
                    const targetId = targetPriority.type === 'hero' ? 'hero-health-board' : 'player-minion-board';
                    const targetEl = document.getElementById(targetId);
                    this.animateSpellProjectile(this.elements.aiHand, targetEl, true);
                    this.addLog(`AI casts ${card.name} at ${targetId === 'hero-health-board' ? 'Player' : 'Players minions'}`);
                    await this.handleDirectDamage(card, 'player', targetId, targetEl, targetPriority);
                } else if (card.type === 'healing') {
                    const targetId = this.state.ai.health < 20 ? 'ai-health-board' : 'ai-minion-board';
                    const targetEl = document.getElementById(targetId);
                    await this.handleHealing(card, 'ai', targetId, targetEl);
                } else if (card.type === 'spell') {
                    this.state.ai.mana = Math.min(this.state.ai.maxMana, this.state.ai.mana + 2);
                    this.addLog(`AI gains 2 mana with ${card.name}`);
                    this.animateManaGain(document.getElementById('ai-health-board'));
                    await new Promise(resolve => setTimeout(resolve, 800));
                } else if (card.type === 'spellDraw') {
                    this.drawCards('ai', 2);
                    this.addLog(`AI draws 2 cards with ${card.name}`);
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
                this.state.ai.graveyard.push(card);
                this.update();
            }

            async aiAttack(minion, targetPriority) {
                const cardEl = this.elements.aiBoard.querySelector(`[data-card='${JSON.stringify(minion.card)}']`);
                cardEl.classList.add('attack-animation');
                const targetId = targetPriority.type === 'hero' ? 'hero-health-board' : 'player-minion-board';
                const targetEl = document.getElementById(targetId);
                this.animateDamageCircles(targetEl);
                this.attackWithMinion(minion, 'player', targetId, targetPriority);
                minion.exhausted = true;
                await new Promise(resolve => setTimeout(() => {
                    cardEl.classList.remove('attack-animation');
                    resolve();
                }, 800));
            }

            selectCard(card) {
                if (this.state.turn !== 'player' || this.state.gameOver) return;
                if (this.state.selectedCard?.uid === card.uid) {
                    this.state.selectedCard = null;
                    this.state.attackingMinion = null;
                } else if (this.state.player.hand.some(c => c.uid === card.uid) && this.state.player.mana >= card.cost) {
                    this.state.selectedCard = card;
                    this.state.attackingMinion = null;
                } else if (this.canAttack(card)) {
                    this.state.selectedCard = card;
                    this.state.attackingMinion = this.state.player.board.find(m => m.card.uid === card.uid);
                }
                this.update();
            }

            handleDragStart(card, e) {
                if (this.state.turn !== 'player' || this.state.gameOver) return;
                if (this.state.player.hand.some(c => c.uid === card.uid) && this.state.player.mana >= card.cost) {
                    this.state.selectedCard = card;
                    this.state.attackingMinion = null;
                } else if (this.canAttack(card)) {
                    this.state.selectedCard = card;
                    this.state.attackingMinion = this.state.player.board.find(m => m.card.uid === card.uid);
                }
                e.dataTransfer.setData('text/plain', JSON.stringify(card));
            }

            handleDrop(e) {
                e.preventDefault();
                if (!this.state.selectedCard || this.state.turn !== 'player' || this.state.gameOver) return;
                const target = e.target.closest('.drop-target');
                if (!target) return;
                const targetId = target.id || (target.dataset.card ? 'card' : '');

                if (this.state.player.hand.some(c => c.uid === this.state.selectedCard.uid)) {
                    this.playCard(targetId, target);
                } else if (this.state.attackingMinion) {
                    this.attack(targetId, target);
                }
                this.state.selectedCard = null;
                this.state.attackingMinion = null;
                this.update();
            }

            handleBoardClick(e) {
                if (!this.state.attackingMinion || this.state.turn !== 'player' || this.state.gameOver) return;
                const targetCardEl = e.target.closest('.card');
                if (targetCardEl) {
                    const targetCard = JSON.parse(targetCardEl.dataset.card);
                    this.attackMinion(targetCard, targetCardEl);
                }
            }

            async playCard(targetId, targetEl) {
                const card = this.state.selectedCard;
                if (this.state.player.mana < card.cost) return;
                this.state.player.mana -= card.cost;
                this.state.player.hand = this.state.player.hand.filter(c => c.uid !== card.uid);

                if (card.type === 'minion' && targetId === 'player-minion-board' && this.state.player.board.length < this.maxBoardSize) {
                    this.state.player.board.push({ card, exhausted: true, armor: 0 });
                    this.addLog(`Player plays ${card.name}`);
                    if (card.ability === 'dealDamage') {
                        await this.handleDealDamage(card, 'ai', this.elements.aiBoard);
                    } else if (card.ability === 'boostAllies') {
                        this.state.player.board.forEach(m => m.card.attack += card.boostAttack);
                        this.addLog(`Player's ${card.name} gives all allies +${card.boostAttack} attack`);
                        await new Promise(resolve => setTimeout(resolve, 800));
                    } else if (card.ability) {
                        await this.handleSpecialAbility(card, 'player', targetId, targetEl);
                    }
                } else if (card.type === 'directDamage') {
                    await this.handleDirectDamage(card, 'ai', targetId, targetEl);
                } else if (card.type === 'healing') {
                    await this.handleHealing(card, targetId.includes('ai') ? 'ai' : 'player', targetId, targetEl);
                } else if (card.type === 'spell') {
                    this.state.player.mana = Math.min(this.state.player.maxMana, this.state.player.mana + 2);
                    this.addLog(`Player gains 2 mana with ${card.name}`);
                    this.animateManaGain(document.getElementById('hero-health-board'));
                    await new Promise(resolve => setTimeout(resolve, 800));
                } else if (card.type === 'spellDraw') {
                    this.drawCards('player', 2);
                    this.addLog(`Player draws 2 cards with ${card.name}`);
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
                this.state.player.graveyard.push(card);
                this.checkGameEnd();
                this.update();
            }

            async handleDealDamage(card, targetPlayer, targetEl, targetPriority = null) {
                const target = this.state[targetPlayer];
                const damage = card.damage || (card.ability === 'dealDamage' ? card.damage : 0);
                this.animateSpellProjectile(this.elements.playerHand, targetEl, false);
                await new Promise(resolve => setTimeout(resolve, 800));

                if (target.board.some(m => m.card.taunt) && (!targetPriority || targetPriority.type !== 'minion')) {
                    const tauntMinion = target.board.find(m => m.card.taunt);
                    this.applyDamage(tauntMinion, damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${tauntMinion.card.name} takes ${damage} damage`);
                    this.animateDamageCircles(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard'].querySelector(`[data-card='${JSON.stringify(tauntMinion.card)}']`));
                    this.checkMinionDeath(targetPlayer);
                } else if (targetPriority?.type === 'minion' && target.board.some(m => m.card.uid === targetPriority.target.uid)) {
                    const targetMinion = target.board.find(m => m.card.uid === targetPriority.target.uid);
                    this.applyDamage(targetMinion, damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${targetMinion.card.name} takes ${damage} damage`);
                    this.animateDamageCircles(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard'].querySelector(`[data-card='${JSON.stringify(targetMinion.card)}']`));
                    this.checkMinionDeath(targetPlayer);
                } else if (target.board.length > 0 && Math.random() > 0.3) {
                    const targetMinion = target.board[Math.floor(Math.random() * target.board.length)];
                    this.applyDamage(targetMinion, damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${targetMinion.card.name} takes ${damage} damage`);
                    this.animateDamageCircles(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard'].querySelector(`[data-card='${JSON.stringify(targetMinion.card)}']`));
                    this.checkMinionDeath(targetPlayer);
                } else {
                    this.applyDamageToHero(target, damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'} takes ${damage} damage from ${card.name}`);
                    this.animateDamageCircles(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard']);
                }
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            async handleDirectDamage(card, targetPlayer, targetId, targetEl, targetPriority = null) {
                const target = this.state[targetPlayer];
                const actualTargetEl = targetId.includes('card') ? targetEl : document.getElementById(targetId);
                this.animateSpellProjectile(this.elements.playerHand, actualTargetEl, false);
                await new Promise(resolve => setTimeout(resolve, 800));

                if (targetId.includes('card')) {
                    const targetCard = JSON.parse(targetEl.dataset.card);
                    const targetMinion = target.board.find(m => m.card.uid === targetCard.uid);
                    if (targetMinion) {
                        this.applyDamage(targetMinion, card.damage, targetPlayer);
                        this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${targetMinion.card.name} takes ${card.damage} damage`);
                        this.animateDamageCircles(targetEl);
                        this.checkMinionDeath(targetPlayer);
                    }
                } else if (target.board.some(m => m.card.taunt) && targetId === (targetPlayer === 'ai' ? 'ai-health-board' : 'hero-health-board')) {
                    const tauntMinion = target.board.find(m => m.card.taunt);
                    this.applyDamage(tauntMinion, card.damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${tauntMinion.card.name} takes ${card.damage} damage`);
                    this.animateDamageCircles(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard'].querySelector(`[data-card='${JSON.stringify(tauntMinion.card)}']`));
                    this.checkMinionDeath(targetPlayer);
                } else if (targetId === (targetPlayer === 'ai' ? 'ai-health-board' : 'hero-health-board')) {
                    this.applyDamageToHero(target, card.damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'} takes ${card.damage} damage from ${card.name}`);
                    this.animateDamageCircles(actualTargetEl);
                } else if (targetId === (targetPlayer === 'ai' ? 'ai-minion-board' : 'player-minion-board') && target.board.length > 0) {
                    const targetMinion = target.board[Math.floor(Math.random() * target.board.length)];
                    this.applyDamage(targetMinion, card.damage, targetPlayer);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${targetMinion.card.name} takes ${card.damage} damage`);
                    this.animateDamageCircles(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard'].querySelector(`[data-card='${JSON.stringify(targetMinion.card)}']`));
                    this.checkMinionDeath(targetPlayer);
                }
                this.update();
            }

            async handleHealing(card, targetPlayer, targetId, targetEl) {
                const target = this.state[targetPlayer];
                this.animateSpellProjectile(this.elements.playerHand, targetEl, false);
                await new Promise(resolve => setTimeout(resolve, 800));

                if (targetId.includes('card')) {
                    const targetCard = JSON.parse(targetEl.dataset.card);
                    const targetMinion = target.board.find(m => m.card.uid === targetCard.uid);
                    if (targetMinion) {
                        targetMinion.card.health = Math.min(this.maxHealth, targetMinion.card.health + card.healing);
                        this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${targetMinion.card.name} healed for ${card.healing}`);
                        this.animateHeal(targetEl);
                    }
                } else if (targetId === (targetPlayer === 'ai' ? 'ai-health-board' : 'hero-health-board')) {
                    target.health = Math.min(this.maxHealth, target.health + card.healing);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'} healed for ${card.healing} with ${card.name}`);
                    this.animateHeal(targetEl);
                } else if (targetId === (targetPlayer === 'ai' ? 'ai-minion-board' : 'player-minion-board') && target.board.length > 0) {
                    const targetMinion = target.board.reduce((min, m) => m.card.health < min.card.health ? m : min);
                    targetMinion.card.health = Math.min(this.maxHealth, targetMinion.card.health + card.healing);
                    this.addLog(`${targetPlayer === 'player' ? 'Player' : 'AI'}'s ${targetMinion.card.name} healed for ${card.healing}`);
                    this.animateHeal(this.elements[targetPlayer === 'ai' ? 'aiBoard' : 'playerBoard'].querySelector(`[data-card='${JSON.stringify(targetMinion.card)}']`));
                }
                this.update();
            }

            async handleSpecialAbility(card, player, targetId, targetEl) {
                if (card.ability === 'summon') {
                    const summonCount = card.summonCount || 2;
                    const summonedCard = season0.find(c => c.cost === 1 && c.type === 'minion');
                    if (summonedCard && this.state[player].board.length + summonCount <= this.maxBoardSize) {
                        for (let i = 0; i < summonCount; i++) {
                            const newCard = { ...summonedCard, uid: Math.random().toString(36).substr(2, 9) };
                            this.state[player].board.push({ card: newCard, exhausted: true, armor: 0 });
                            this.addLog(`${player === 'player' ? 'Player' : 'AI'} summons ${newCard.name}`);
                            this.animateSpellProjectile(this.elements[player === 'player' ? 'playerHand' : 'aiHand'], targetEl, player !== 'player');
                            await new Promise(resolve => setTimeout(resolve, 800));
                        }
                    }
                }
                this.update();
            }

            applyDamage(minion, damage, player) {
                if (minion.armor > 0) {
                    const armorDamage = Math.min(minion.armor, damage);
                    minion.armor -= armorDamage;
                    damage -= armorDamage;
                    this.addLog(`${player === 'player' ? 'Player' : 'AI'}'s ${minion.card.name} loses ${armorDamage} armor`);
                }
                if (damage > 0) {
                    minion.card.health = Math.max(0, minion.card.health - damage);
                }
            }

            applyDamageToHero(target, damage, player) {
                if (target.armor > 0) {
                    const armorDamage = Math.min(target.armor, damage);
                    target.armor -= armorDamage;
                    damage -= armorDamage;
                    this.addLog(`${player === 'player' ? 'Player' : 'AI'} loses ${armorDamage} armor`);
                }
                if (damage > 0) {
                    target.health = Math.max(0, target.health - damage);
                }
            }

            attack(targetId, targetEl) {
                const minion = this.state.attackingMinion;
                if (!minion || minion.exhausted) return;
                const cardEl = this.elements.playerBoard.querySelector(`[data-card='${JSON.stringify(minion.card)}']`);
                const actualTargetEl = targetId.includes('card') ? targetEl : document.getElementById(targetId);
                cardEl.classList.add('attack-animation');
                this.animateDamageCircles(actualTargetEl);

                if ((targetId === 'ai-health-board' || targetId === 'ai-hero-image' || targetId === 'ai-stats-box') && !this.state.ai.board.some(m => m.card.taunt)) {
                    this.applyDamageToHero(this.state.ai, minion.card.attack, 'ai');
                    this.addLog(`Player's ${minion.card.name} attacks AI for ${minion.card.attack}`);
                    minion.exhausted = true;
                } else if (targetId === 'ai-minion-board' && this.state.ai.board.length > 0) {
                    const targetMinion = this.state.ai.board[Math.floor(Math.random() * this.state.ai.board.length)];
                    this.attackMinion(targetMinion.card, this.elements.aiBoard.querySelector(`[data-card='${JSON.stringify(targetMinion.card)}']`));
                } else if (targetId.includes('card')) {
                    const targetCard = JSON.parse(targetEl.dataset.card);
                    this.attackMinion(targetCard, targetEl);
                }

                setTimeout(() => cardEl.classList.remove('attack-animation'), 500);
                this.checkGameEnd();
                this.update();
            }

            attackMinion(targetCard, targetEl) {
                const minion = this.state.attackingMinion;
                if (!minion || minion.exhausted) return;
                const targetMinion = this.state.ai.board.find(m => m.card.uid === targetCard.uid);
                if (!targetMinion || (this.state.ai.board.some(m => m.card.taunt) && !targetMinion.card.taunt)) return;

                const cardEl = this.elements.playerBoard.querySelector(`[data-card='${JSON.stringify(minion.card)}']`);
                cardEl.classList.add('attack-animation');
                this.animateDamageCircles(targetEl);

                this.applyDamage(targetMinion, minion.card.attack, 'ai');
                this.applyDamage(minion, targetMinion.card.attack, 'player');
                this.addLog(`Player's ${minion.card.name} attacks ${targetMinion.card.name} for ${minion.card.attack}`);
                minion.exhausted = true;

                this.checkMinionDeath('player');
                this.checkMinionDeath('ai');
                setTimeout(() => cardEl.classList.remove('attack-animation'), 500);
                this.checkGameEnd();
                this.update();
            }

            attackWithMinion(minion, targetPlayer, targetId, targetPriority) {
                const target = this.state[targetPlayer];
                if (target.board.some(m => m.card.taunt) && targetId !== 'player-minion-board') {
                    const tauntMinion = target.board.find(m => m.card.taunt);
                    this.applyDamage(tauntMinion, minion.card.attack, targetPlayer);
                    this.applyDamage(minion, tauntMinion.card.attack, 'ai');
                    this.addLog(`AI's ${minion.card.name} attacks ${tauntMinion.card.name} for ${minion.card.attack}`);
                    this.checkMinionDeath(targetPlayer);
                    this.checkMinionDeath('ai');
                } else if (targetPriority?.type === 'minion' && target.board.some(m => m.card.uid === targetPriority.target.uid)) {
                    const targetMinion = target.board.find(m => m.card.uid === targetPriority.target.uid);
                    this.applyDamage(targetMinion, minion.card.attack, targetPlayer);
                    this.applyDamage(minion, targetMinion.card.attack, 'ai');
                    this.addLog(`AI's ${minion.card.name} attacks ${targetMinion.card.name} for ${minion.card.attack}`);
                    this.checkMinionDeath(targetPlayer);
                    this.checkMinionDeath('ai');
                } else {
                    this.applyDamageToHero(target, minion.card.attack, targetPlayer);
                    this.addLog(`AI's ${minion.card.name} attacks ${targetPlayer === 'player' ? 'Player' : 'AI'} for ${minion.card.attack}`);
                }
            }

            checkMinionDeath(player) {
                const target = this.state[player];
                target.board = target.board.filter(m => {
                    if (m.card.health <= 0) {
                        target.graveyard.push(m.card);
                        this.addLog(`${player === 'player' ? 'Player' : 'AI'}'s ${m.card.name} dies`);
                        return false;
                    }
                    return true;
                });
                this.update();
            }

            canAttack(card) {
                const minion = this.state.player.board.find(m => m.card.uid === card.uid);
                return minion && !minion.exhausted && minion.card.attack > 0 && minion.card.health > 0 && (minion.turnsOnBoard || 0) >= 1;
            }

            checkGameEnd() {
                if (this.state.player.health <= 0) {
                    this.state.gameOver = true;
                    this.state.aiWins++;
                    this.showEndGame(false);
                } else if (this.state.ai.health <= 0) {
                    this.state.gameOver = true;
                    this.state.playerWins++;
                    this.showEndGame(true);
                }
            }

            showEndGame(playerWon) {
                this.elements.gameOver.style.display = 'block';
                this.elements.gameOver.innerHTML = `
                    <h2>${playerWon ? 'Victory!' : 'Defeat!'}</h2>
                    <p>${playerWon ? 'You defeated the AI!' : 'The AI has bested you.'}</p>
                    <p>Player Wins: ${this.state.playerWins} | AI Wins: ${this.state.aiWins}</p>
                    <button onclick="document.querySelector('#restart-btn').click()">Play Again</button>
                    <button onclick="document.querySelector('#back-to-codex-btn').click()">Back to Codex</button>
                `;
                this.elements.backToCodexBtn.style.display = 'block';
                this.elements.backToCodexBtn.dataset.result = playerWon ? 'win' : 'loss';
            }

            backToCodex() {
                const result = this.elements.backToCodexBtn.dataset.result;
                const gBux = result === 'win' ? 10 : 5;
                window.location.href = `https://www.grudgeplatform.com/Season0?result=${result}&gBux=${gBux}`;
            }

            restart() {
                this.state = {
                    player: { health: 30, mana: 0, maxMana: 0, hand: [], board: [], deck: [], graveyard: [], armor: 0 },
                    ai: { health: 30, mana: 0, maxMana: 0, hand: [], board: [], deck: [], graveyard: [], armor: 0 },
                    turn: 'player',
                    turnNumber: 1,
                    selectedCard: null,
                    attackingMinion: null,
                    gameOver: false,
                    startingDeck: [],
                    swapsLeft: 3,
                    playerWins: this.state.playerWins,
                    aiWins: this.state.aiWins
                };
                this.elements.log.innerHTML = 'Battle Log';
                this.elements.gameOver.style.display = 'none';
                this.elements.backToCodexBtn.style.display = 'none';
                this.init();
            }

            update() {
                document.getElementById('player-health').textContent = this.state.player.health;
                document.getElementById('player-mana').textContent = this.state.player.mana;
                document.getElementById('player-max-mana').textContent = this.state.player.maxMana;
                document.getElementById('ai-health').textContent = this.state.ai.health;
                document.getElementById('ai-mana').textContent = this.state.ai.mana;
                document.getElementById('ai-max-mana').textContent = this.state.ai.maxMana;
                this.elements.endTurnBtn.disabled = this.state.turn !== 'player' || this.state.gameOver || this.state.startingDeck.length;
                this.elements.turnIndicator.textContent = `${this.state.turn === 'player' ? 'Player' : 'AI'}'s Turn`;
                this.elements.manaFill.style.width = `${(this.state.player.mana / this.state.player.maxMana) * 100 || 0}%`;

                this.elements.playerHand.innerHTML = '';
                this.state.player.hand.forEach(card => {
                    const cardEl = this.createCard(card);
                    this.elements.playerHand.appendChild(cardEl);
                });

                this.elements.playerBoard.innerHTML = '';
                this.state.player.board.forEach(m => {
                    const cardEl = this.createCard(m.card);
                    this.elements.playerBoard.appendChild(cardEl);
                });

                this.elements.aiBoard.innerHTML = '';
                this.state.ai.board.forEach(m => {
                    const cardEl = this.createCard(m.card, false);
                    this.elements.aiBoard.appendChild(cardEl);
                });

                this.elements.aiHand.innerHTML = '';
                this.state.ai.hand.forEach(() => {
                    const cardBack = document.createElement('div');
                    cardBack.className = 'ai-card-back';
                    this.elements.aiHand.appendChild(cardBack);
                });

                this.elements.deck.textContent = `Deck: ${this.state.player.deck.length}`;
                this.elements.graveyard.innerHTML = this.state.player.graveyard.map(c => `<div class="graveyard-card">${c.name}</div>`).join('');
                this.elements.aiGraveyard.innerHTML = this.state.ai.graveyard.map(c => `<div class="graveyard-card">${c.name}</div>`).join('');
            }

            addLog(message) {
                const logEntry = document.createElement('p');
                logEntry.textContent = message;
                this.elements.log.appendChild(logEntry);
                this.elements.log.scrollTop = this.elements.log.scrollHeight;
            }

            animateHeal(targetEl) {
                if (targetEl) {
                    targetEl.classList.add('heal-animation');
                    setTimeout(() => targetEl.classList.remove('heal-animation'), 1000);
                }
            }

            animateSpellProjectile(startEl, targetEl, isAI) {
                const projectile = document.createElement('div');
                projectile.className = 'spell-projectile';
                const startRect = startEl.getBoundingClientRect();
                const targetRect = targetEl.getBoundingClientRect();
                projectile.style.left = `${startRect.left + startRect.width / 2}px`;
                projectile.style.top = `${startRect.top + startRect.height / 2}px`;
                document.body.appendChild(projectile);

                const dx = targetRect.left + targetRect.width / 2 - (startRect.left + startRect.width / 2);
                const dy = targetRect.top + targetRect.height / 2 - (startRect.top + startRect.height / 2);
                projectile.style.transform = `translate(${dx}px, ${dy}px)`;
                setTimeout(() => {
                    projectile.remove();
                    this.animateSpellImpact(targetEl);
                }, 800);
            }

            animateSpellImpact(targetEl) {
                const impact = document.createElement('div');
                impact.className = 'spell-impact';
                const targetRect = targetEl.getBoundingClientRect();
                impact.style.left = `${targetRect.left + targetRect.width / 2 - 50}px`;
                impact.style.top = `${targetRect.top + targetRect.height / 2 - 50}px`;
                document.body.appendChild(impact);
                setTimeout(() => impact.remove(), 600);
            }

            animateDamageCircles(targetEl) {
                const container = document.createElement('div');
                container.className = 'damage-circles';
                const targetRect = targetEl.getBoundingClientRect();
                container.style.left = `${targetRect.left + targetRect.width / 2 - 40}px`;
                container.style.top = `${targetRect.top + targetRect.height / 2 - 40}px`;
                document.body.appendChild(container);

                for (let i = 0; i < 3; i++) {
                    const circle = document.createElement('div');
                    circle.className = 'damage-circle';
                    circle.style.left = `${Math.random() * 40}px`;
                    circle.style.top = `${Math.random() * 40}px`;
                    container.appendChild(circle);
                }
                setTimeout(() => container.remove(), 500);
            }

            animateManaGain(targetEl) {
                targetEl.classList.add('mana-gain');
                setTimeout(() => targetEl.classList.remove('mana-gain'), 700);
            }
        }

        document.addEventListener('DOMContentLoaded', () => new Game().init());
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9389d2a49a7990ed',t:'MTc0NjA0NTI5Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
